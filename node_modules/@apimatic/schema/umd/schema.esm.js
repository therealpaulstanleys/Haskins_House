function e(e){const t=[];for(let n=0;n<e.length;n++){const a=e[n];t.push([n,a])}return t}function t(e){const t=Object.keys(e);let n=t.length;const a=new Array(n);for(;n--;)a[n]=[t[n],e[t[n]]];return a}function n(e){return"string"==typeof e?`"${e.replace(/"/g,'"')}"`:`${e}`}function a(e){return e}function r(e){return(t,n)=>e(t,n.strictValidation)?[]:n.fail()}function o(e){return t={type:()=>e.type,validateBeforeMap:e.validate,validateBeforeUnmap:e.validate,map:e.map,unmap:e.map},Object.assign(Object.assign({},t),{validateBeforeMapXml:t.validateBeforeUnmap,mapXml:t.map,unmapXml:t.unmap});var t}function l(e,t){return t?"number"==typeof e:"number"==typeof e||"string"==typeof e&&!isNaN(e)}function i(e){return"number"==typeof e?e:+e}function p(e){return"bigint"==typeof e?e:BigInt(e)}function u(e,t){const n=new Set(t),a={};for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&!n.has(t)&&(a[t]=e[t]);return a}function m(e){return-1!==e.indexOf(" ")?n(e):e}function c(e){return null==e}function f(e,t){return e.startsWith("Optional<")&&void 0===t}function s(e,t){return function(e){return e.startsWith("Optional<Nullable<")||e.startsWith("Nullable<Optional<")}(e)&&c(t)}function d(e,t){const n=B(b(e,t.type())),a=t.validateBeforeMap(e,n);return 0===a.length?s(t.type(),e)?{errors:!1,result:e}:{errors:!1,result:t.map(e,n)}:{errors:a}}function y(e,t){const n=B(b(e,t.type())),a=t.validateBeforeUnmap(e,n);return 0===a.length?{errors:!1,result:t.unmap(e,n)}:{errors:a}}function v(e,t){const n=B(b(e,t.type())),a=t.validateBeforeMapXml(e,n);return 0===a.length?{errors:!1,result:t.mapXml(e,n)}:{errors:a}}function h(e,t){const n=B(b(e,t.type())),a=t.validateBeforeUnmap(e,n);return 0===a.length?{errors:!1,result:t.unmapXml(e,n)}:{errors:a}}function b(e,t,n){return{value:e,type:t,branch:[e],path:[],strictValidation:n}}function B(e){const t=(t,n,a)=>B({value:n,type:a.type(),branch:[...e.branch,n],path:[...e.path,t],strictValidation:e.strictValidation}),n=(e,n,a)=>e.map((e=>a(e,t(e[0],e[1],n))));return Object.assign(Object.assign({},e),{createChild:t,flatmapChildren:(...e)=>function(e){const t=[];for(const n of e)for(const e of n)t.push(e);return t}(n(...e)),mapChildren:n,fail:t=>[{value:e.value,type:e.type,branch:e.branch,path:e.path,message:X(e,t)}]})}function X(e,t){const n=JSON.stringify(e.value,((e,t)=>"bigint"==typeof t?t.toString():t));if(t=(null!=t?t:`Expected value to be of type '${e.type}' but found '${typeof e.value}'.`)+"\n"+`\nGiven value: ${n}`+`\nType: '${typeof e.value}'`+`\nExpected type: '${e.type}'`,e.path.length>0){t+=`\nPath: ${e.path.map((e=>m(e.toString()))).join(" â€º ")}`}return t}function j(e,t,n){return t&&n?function(e,t,n){return{type:()=>`OneOf<${e.map((e=>e.type())).join(" | ")}>`,validateBeforeMap:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeMap(a,r):g(e,a,r)},validateBeforeUnmap:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeUnmap(a,r):O(e,a,r)},map:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].map(a,r):x(e,a,r)},unmap:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].unmap(a,r):U(e,a,r)},validateBeforeMapXml:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeMapXml(a,r):M(e,a,r)},mapXml:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].mapXml(a,r):S(e,a,r)},unmapXml:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].unmapXml(a,r):N(e,a,r)}}}(e,t,n):function(e){return{type:()=>`OneOf<${e.map((e=>e.type())).join(" | ")}>`,validateBeforeMap:(t,n)=>g(e,t,n),validateBeforeUnmap:(t,n)=>O(e,t,n),map:(t,n)=>x(e,t,n),unmap:(t,n)=>U(e,t,n),validateBeforeMapXml:(t,n)=>M(e,t,n),mapXml:(t,n)=>S(e,t,n),unmapXml:(t,n)=>N(e,t,n)}}(e)}function g(e,t,n){const a=[];for(const r of e){0===r.validateBeforeMap(t,n).length&&a.push(r)}return $(a,n)}function O(e,t,n){const a=[];for(const r of e){0===r.validateBeforeUnmap(t,n).length&&a.push(r)}return $(a,n)}function M(e,t,n){const a=[];for(const r of e){0===r.validateBeforeMapXml(t,n).length&&a.push(r)}return $(a,n)}function $(e,t){return e.length>0?[]:t.fail("Could not match against any acceptable type.")}function x(e,t,n){const a=[];for(const r of e)0===r.validateBeforeMap(t,n).length&&a.push(r);return a.length>0?a[0].map(t,n):void 0}function U(e,t,n){const a=[];for(const r of e)0===r.validateBeforeUnmap(t,n).length&&a.push(r);return a.length>0?a[0].unmap(t,n):void 0}function S(e,t,n){const a=[];for(const r of e)0===r.validateBeforeMapXml(t,n).length&&a.push(r);return a.length>0?a[0].mapXml(t,n):void 0}function N(e,t,n){const a=[];for(const r of e)0===r.validateBeforeMapXml(t,n).length&&a.push(r);return a.length>0?a[0].unmapXml(t,n):void 0}function w(t,n){let a;return a={type:()=>`Array<${t.type()}>`,validateBeforeMap:(n,a)=>Array.isArray(n)?a.flatmapChildren(e(n),t,((e,n)=>t.validateBeforeMap(e[1],n))):a.fail(),validateBeforeUnmap:(n,a)=>Array.isArray(n)?a.flatmapChildren(e(n),t,((e,n)=>t.validateBeforeUnmap(e[1],n))):a.fail(),map:(n,a)=>a.mapChildren(e(n),t,((e,n)=>t.map(e[1],n))),unmap:(n,a)=>a.mapChildren(e(n),t,((e,n)=>t.unmap(e[1],n))),mapXml:(a,r)=>{let o=a;return(null==n?void 0:n.xmlItemName)&&(o=a[n.xmlItemName],r=r.createChild(n.xmlItemName,o,t)),r.mapChildren(e(o),t,((e,n)=>t.mapXml(e[1],n)))},unmapXml:(a,r)=>{const o=r.mapChildren(e(a),t,((e,n)=>t.unmapXml(e[1],n)));return(null==n?void 0:n.xmlItemName)?{[n.xmlItemName]:o}:o},validateBeforeMapXml:(a,r)=>{let o=a;if(null==n?void 0:n.xmlItemName){const e=`Expected array to be wrapped with XML element ${n.xmlItemName}.`;if("object"!=typeof a||null===a||!(n.xmlItemName in a))return r.fail(e);o=a[n.xmlItemName],r=r.createChild(n.xmlItemName,o,t)}return Array.isArray(o)?r.flatmapChildren(e(o),t,((e,n)=>t.validateBeforeMapXml(e[1],n))):r.fail()}},a}function A(e,t){return t?"bigint"==typeof e:"bigint"==typeof e||"number"==typeof e||"string"==typeof e&&/^-?\d+$/.test(e)}function P(){return o({type:"bigint",validate:r(A),map:p})}function C(e,t){return t?"boolean"==typeof e:"boolean"==typeof e||"string"==typeof e&&("true"===e||"false"===e)}function T(){return o({type:"boolean",validate:r(C),map:e=>"boolean"==typeof e?e:"true"===e})}function k(e,t){return{type:()=>`Defaults<${e.type()},${n(t)}>`,validateBeforeMap:(n,a)=>I(n,t)?[]:e.validateBeforeMap(n,a),validateBeforeUnmap:(n,a)=>I(n,t)?[]:e.validateBeforeUnmap(n,a),map:(n,a)=>I(n,t)?t:e.map(n,a),unmap:(n,a)=>I(n,t)?t:e.unmap(n,a),validateBeforeMapXml:(n,a)=>I(n,t)?[]:e.validateBeforeMapXml(n,a),mapXml:(n,a)=>I(n,t)?t:e.mapXml(n,a),unmapXml:(n,a)=>I(n,t)?t:e.unmapXml(n,a)}}function I(e,t){return null==e||e===t}function E(e){const n=(n,a,r)=>{if("object"!=typeof a||null===a)return r.fail();const o=a;return r.flatmapChildren(t(o),e,((t,a)=>e[n](t[1],a)))};return{type:()=>`Record<string,${e.type()}>`,validateBeforeMap:(...e)=>n("validateBeforeMap",...e),validateBeforeUnmap:(...e)=>n("validateBeforeUnmap",...e),map:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.map(o,n.createChild(r,o,e))}return a},unmap:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.unmap(o,n.createChild(r,o,e))}return a},validateBeforeMapXml:(...e)=>n("validateBeforeMapXml",...e),mapXml:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.mapXml(o,n.createChild(r,o,e))}return a},unmapXml:(t,n)=>{const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){const o=t[r];a[r]=e.unmapXml(o,n.createChild(r,o,e))}return a}}}function V(e){const n=E(e),a=Object.assign({},n);return a.unmapXml=(e,a)=>({entry:t(n.unmapXml(e,a)).map((([e,t])=>({$:{key:e},_:t})))}),a.mapXml=(e,t)=>{if(!("entry"in e))return{};let{entry:a}=e;Array.isArray(a)||(a=[a]);const r={};for(const e of a)r[e.$.key]=e._;return n.mapXml(r,t)},a.validateBeforeMapXml=(e,t)=>{if("object"!=typeof e||null===e)return t.fail();if(!("entry"in e))return[];let a=e.entry;Array.isArray(a)||(a=[a]);const r={};for(const e of a){if("object"!=typeof e||null===e)return t.fail('Expected "entry" to be an XML element.');if(!("$"in e)||!("key"in e.$))return t.fail('Expected "entry" element to have an attribute named "key".');const n=e;r[n.$.key]=n._}return n.validateBeforeMapXml(r,t)},a}function W(e,n,a,r,o){const l=Object.values(a).reverse(),i=(e,t,n,o)=>{const i=((e,t,n)=>{if("object"==typeof e&&null!==e&&(n&&function(e,t){return"$"in e&&"object"==typeof e.$&&t in e.$}(e,t)||!n&&t in e)){const r=n?e.$[t]:e[t];if("string"==typeof r&&r in a)return a[r]}})(e,t,o);if(void 0!==i)return i;for(const e in l)if(0===n(l[e]).length)return l[e];return a[r]},p=(e,t)=>i(e,n,(n=>n.validateBeforeMap(e,t))),u=(e,t)=>{var a;return i(e,null!==(a=null==o?void 0:o.xmlName)&&void 0!==a?a:n,(n=>n.validateBeforeMapXml(e,t)),null==o?void 0:o.isAttr)},m=(t,n)=>i(t,e,(e=>e.validateBeforeUnmap(t,n)));return{type:()=>`DiscriminatedUnion<${n},[${t(a).map((([e,t])=>t.type)).join(",")}]>`,map:(e,t)=>p(e,t).map(e,t),unmap:(e,t)=>m(e,t).unmap(e,t),validateBeforeMap:(e,t)=>p(e,t).validateBeforeMap(e,t),validateBeforeUnmap:(e,t)=>m(e,t).validateBeforeUnmap(e,t),mapXml:(e,t)=>u(e,t).mapXml(e,t),unmapXml:(e,t)=>m(e,t).unmapXml(e,t),validateBeforeMapXml:(e,t)=>u(e,t).validateBeforeMapXml(e,t)}}function L(e){const t=function(e){let t,n=!1;return function(...a){return n||(n=!0,t=e.apply(this,a)),t}}(e);return{type:()=>`Lazy<${t().type()}>`,map:(...e)=>t().map(...e),unmap:(...e)=>t().unmap(...e),validateBeforeMap:(...e)=>t().validateBeforeMap(...e),validateBeforeUnmap:(...e)=>t().validateBeforeUnmap(...e),mapXml:(...e)=>t().mapXml(...e),unmapXml:(...e)=>t().unmapXml(...e),validateBeforeMapXml:(...e)=>t().validateBeforeMapXml(...e)}}function _(e){return o({type:`Literal<${n(e)}>`,validate:r((t=>e===t)),map:()=>e})}function D(e){return{type:()=>`Nullable<${e.type()}>`,validateBeforeMap:(t,n)=>c(t)?[]:e.validateBeforeMap(t,n),validateBeforeUnmap:(t,n)=>null===t?[]:e.validateBeforeUnmap(t,n),map:(t,n)=>c(t)?null:e.map(t,n),unmap:(t,n)=>null===t?null:e.unmap(t,n),validateBeforeMapXml:(t,n)=>null===t?[]:e.validateBeforeMapXml(t,n),mapXml:(t,n)=>null===t?null:e.mapXml(t,n),unmapXml:(t,n)=>null===t?null:e.unmapXml(t,n)}}function z(){return o({type:"number",validate:r(l),map:i})}function G(e,t=!1){const n=r(function(e,t=!1){const n=Object.values(e);return t?e=>l(e):e=>l(e)&&n.includes(i(e))}(e,t));return o({type:`Enum<${Object.values(e).filter((e=>"number"==typeof e)).join(",")}>`,map:i,validate:n})}function J(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n}function R(e){const t=Y(e,!1,!1);return t.type=()=>`StrictObject<{${Object.keys(e).map(m).join(",")}}>`,t}function q(e){return Y(e,!0,!0)}function F(e){const t=Y(e,!0,!1);return t.type=()=>`Object<{${Object.keys(e).map(m).join(",")}}>`,t}function H(e,t){return R(Object.assign(Object.assign({},e.objectSchema),t))}function K(e,t){return q(Object.assign(Object.assign({},e.objectSchema),t))}function Q(e,t){return F(Object.assign(Object.assign({},e.objectSchema),t))}function Y(e,t,n){const a=Object.keys(e),r=oe(e),o=function(e){var t,n;const a={},r={};for(const o in e)if(Object.prototype.hasOwnProperty.call(e,o)){const[l,,i]=e[o];!0===(null==i?void 0:i.isAttr)?r[null!==(t=i.xmlName)&&void 0!==t?t:l]=o:a[null!==(n=null==i?void 0:i.xmlName)&&void 0!==n?n:l]=o}return{elementsToProps:a,attributesToProps:r}}(e),l=function(e){var t;const n={},a={};for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const o=e[r],[l,i,p]=o;((null==p?void 0:p.isAttr)?a:n)[r]=[null!==(t=null==p?void 0:p.xmlName)&&void 0!==t?t:l,i,p]}return{elementsSchema:n,attributesSchema:a}}(e),i=function(e){return{attributesSchema:oe(e.attributesSchema),elementsSchema:oe(e.elementsSchema)}}(l);return{type:()=>`Object<{${a.map(m).join(",")},...}>`,validateBeforeMap:ae(e,"validateBeforeMap",t),validateBeforeUnmap:ae(r,"validateBeforeUnmap",t),map:re(e,"map",n),unmap:re(r,"unmap",n),validateBeforeMapXml:Z(e,o,t),mapXml:ee(l,n),unmapXml:te(i,n),objectSchema:e}}function Z(e,t,n){const{elementsToProps:a,attributesToProps:r}=t;return(t,o)=>{if("object"!=typeof t||null===t)return o.fail();if(Array.isArray(t))return o.fail(`Expected value to be of type '${o.type}' but found 'Array<${typeof t}>'.`);const l=t,{$:i}=l,p=J(l,["$"]),u=null!=i?i:{};return[...ne({validationMethod:"validateBeforeMapXml",propTypeName:"child elements",propTypePrefix:"element",valueTypeName:"element",propMapping:a,objectSchema:e,valueObject:p,ctxt:o,allowAdditionalProperties:n}),...ne({validationMethod:"validateBeforeMapXml",propTypeName:"attributes",propTypePrefix:"@",valueTypeName:"element",propMapping:r,objectSchema:e,valueObject:u,ctxt:o,allowAdditionalProperties:n})]}}function ee(e,n){const{elementsSchema:a,attributesSchema:r}=e,o=re(a,"mapXml",n),l=re(r,"mapXml",!1),i=t(r).map((([e,[t]])=>t));return(e,t)=>{const a=e,{$:r}=a,p=J(a,["$"]),m=null!=r?r:{},c=Object.assign(Object.assign({},l(m,t)),o(p,t));if(n){const e=u(m,i);Object.keys(e).length>0&&(c.$=e)}return c}}function te(e,n){const{elementsSchema:a,attributesSchema:r}=e,o=re(a,"unmapXml",n),l=re(r,"unmapXml",!1),i=t(r).map((([e,[t]])=>t));return(e,t)=>{const a=e,{$:r}=a,p=J(a,["$"]),m="object"==typeof r&&null!==r&&n?r:{};return Object.assign(Object.assign({},o(u(p,i),t)),{$:Object.assign(Object.assign({},m),l(e,t))})}}function ne({validationMethod:e,propTypeName:t,propTypePrefix:a,valueTypeName:r,propMapping:o,objectSchema:l,valueObject:i,ctxt:p,allowAdditionalProperties:u}){const m=[],c=new Set,f=new Set(Object.keys(i));for(const t in o)if(Object.prototype.hasOwnProperty.call(o,t)){const n=l[o[t]][1];f.delete(t),t in i?m.push(...n[e](i[t],p.createChild(a+t,i[t],n))):(s=n.type()).startsWith("Optional<")||s.startsWith("Nullable<")||c.add(t)}var s;const d=Array.from(f);d.length>0&&!u&&m.push(...p.fail(`Some unknown ${t} were found in the ${r}: ${d.map(n).join(", ")}.`));const y=Array.from(c);return y.length>0&&m.push(...p.fail(`Some ${t} are missing in the ${r}: ${y.map(n).join(", ")}.`)),m}function ae(e,t,n){const a=function(e){const t={};for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){t[e[n][0]]=n}return t}(e);return(r,o)=>"object"!=typeof r||null===r?o.fail():Array.isArray(r)?o.fail(`Expected value to be of type '${o.type}' but found 'Array<${typeof r}>'.`):ne({validationMethod:t,propTypeName:"properties",propTypePrefix:"",valueTypeName:"object",propMapping:a,objectSchema:e,valueObject:r,ctxt:o,allowAdditionalProperties:n})}function re(e,t,n){return(a,r)=>{const o={},l=a,i=new Set(Object.keys(l));for(const n in e){if(!Object.prototype.hasOwnProperty.call(e,n))continue;const a=e[n],p=a[0],u=l[p];if(i.delete(p),s(a[1].type(),u)){if(void 0===u)continue;o[n]=null}else f(a[1].type(),u)||(o[n]=a[1][t](u,r.createChild(p,u,a[1])))}return n&&i.forEach((e=>{o[e]=l[e]})),o}}function oe(e){const t={};for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){const a=e[n];t[a[0]]=[n,a[1],a[2]]}return t}function le(e,t,n){return t&&n?function(e,t,n){return{type:()=>`OneOf<${e.map((e=>e.type())).join(" | ")}>`,validateBeforeMap:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeMap(a,r):ie(e,a,r)},validateBeforeUnmap:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeUnmap(a,r):pe(e,a,r)},map:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].map(a,r):ce(e,a,r)},unmap:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].unmap(a,r):fe(e,a,r)},validateBeforeMapXml:(a,r)=>{const o=a&&"object"==typeof a&&a[n];return o&&t[o]?t[o].validateBeforeMapXml(a,r):ue(e,a,r)},mapXml:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].mapXml(a,r):se(e,a,r)},unmapXml:(a,r)=>{const o=a&&a[n];return o&&t[o]?t[o].unmapXml(a,r):de(e,a,r)}}}(e,t,n):function(e){return{type:()=>`OneOf<${e.map((e=>e.type())).join(" | ")}>`,validateBeforeMap:(t,n)=>ie(e,t,n),validateBeforeUnmap:(t,n)=>pe(e,t,n),map:(t,n)=>ce(e,t,n),unmap:(t,n)=>fe(e,t,n),validateBeforeMapXml:(t,n)=>ue(e,t,n),mapXml:(t,n)=>se(e,t,n),unmapXml:(t,n)=>de(e,t,n)}}(e)}function ie(e,t,n){const a=[];n.strictValidation=!0;for(const r of e){0===r.validateBeforeMap(t,n).length&&a.push(r)}return me(a,n)}function pe(e,t,n){const a=[];n.strictValidation=!0;for(const r of e){0===r.validateBeforeUnmap(t,n).length&&a.push(r)}return me(a,n)}function ue(e,t,n){const a=[];n.strictValidation=!0;for(const r of e){0===r.validateBeforeMapXml(t,n).length&&a.push(r)}return me(a,n)}function me(e,t){return 1===e.length?[]:0===e.length?t.fail("Could not match against any acceptable type."):t.fail(`Matched more than one type. Matched types include: ${e.map((e=>e.type())).join(", ")}`)}function ce(e,t,n){const a=[];n.strictValidation=!0;for(const r of e)0===r.validateBeforeMap(t,n).length&&a.push(r);return 1===a.length?a[0].map(t,n):void 0}function fe(e,t,n){const a=[];n.strictValidation=!0;for(const r of e)0===r.validateBeforeUnmap(t,n).length&&a.push(r);return 1===a.length?a[0].unmap(t,n):void 0}function se(e,t,n){const a=[];n.strictValidation=!0;for(const r of e)0===r.validateBeforeMapXml(t,n).length&&a.push(r);return 1===a.length?a[0].mapXml(t,n):void 0}function de(e,t,n){const a=[];n.strictValidation=!0;for(const r of e)0===r.validateBeforeMapXml(t,n).length&&a.push(r);return 1===a.length?a[0].unmapXml(t,n):void 0}function ye(e){return{type:()=>`Optional<${e.type()}>`,validateBeforeMap:(t,n)=>c(t)?[]:e.validateBeforeMap(t,n),validateBeforeUnmap:(t,n)=>void 0===t?[]:e.validateBeforeUnmap(t,n),map:(t,n)=>c(t)?void 0:e.map(t,n),unmap:(t,n)=>void 0===t?void 0:e.unmap(t,n),validateBeforeMapXml:(t,n)=>void 0===t?[]:e.validateBeforeMapXml(t,n),mapXml:(t,n)=>void 0===t?void 0:e.mapXml(t,n),unmapXml:(t,n)=>void 0===t?void 0:e.unmapXml(t,n)}}function ve(e){return"string"==typeof e}function he(){return o({type:"string",validate:r(ve),map:a})}function be(e,t=!1){const l=r(function(e,t=!1){const n=Object.values(e);return t?e=>"string"==typeof e:e=>"string"==typeof e&&n.includes(e)}(e,t));return o({type:`Enum<${Object.values(e).map(n).join(",")}>`,map:a,validate:l})}function Be(){return o({type:"unknown",validate:()=>[],map:a})}export{j as anyOf,w as array,P as bigint,T as boolean,k as defaults,E as dict,V as dictWithXmlEntries,W as discriminatedObject,q as expandoObject,K as extendExpandoObject,Q as extendObject,H as extendStrictObject,L as lazy,_ as literal,D as nullable,z as number,G as numberEnum,F as object,le as oneOf,ye as optional,R as strictObject,he as string,be as stringEnum,Be as unknown,d as validateAndMap,v as validateAndMapXml,y as validateAndUnmap,h as validateAndUnmapXml};
